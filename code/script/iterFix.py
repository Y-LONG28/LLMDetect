import os
import glob
import subprocess
import logging
from collections import defaultdict
import matplotlib.pyplot as plt
# import seaborn as sns
# from jinja2 import Environment, FileSystemLoader
import openai
from openai import OpenAI
import re
import argparse
# -------------------- Configuration Section --------------------

# OpenAI API configuration
OPENAI_API_KEY = "sk-0dddf3b06675472d9321e3e54e00d1ed"  
OPENAI_API_BASE = "https://api.deepseek.com/v1"  
# Initialize OpenAI API
openai.api_key = OPENAI_API_KEY
openai.api_base = OPENAI_API_BASE

client = OpenAI(api_key=OPENAI_API_KEY, base_url=OPENAI_API_BASE)


parser = argparse.ArgumentParser(description='Preprocess C files')
parser.add_argument('--input_dir', type=str, required=True, help='Input directory path')
parser.add_argument('--output_dir', type=str, required=True, help='Output directory path')

# Parse command-line arguments
args = parser.parse_args()

input_dir = args.input_dir
output_dir = args.output_dir

# Log configuration
LOG_DIR = os.path.join(output_dir, "logs")
os.makedirs(LOG_DIR, exist_ok=True)
logging.basicConfig(
    filename=os.path.join(LOG_DIR, "fix_compile_and_report.log"),
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)


FIXED_CODE_PAIRS = [
    (
        input_dir,
        output_dir
    ),
]

# Define report output directory
REPORT_OUTPUT_DIR = os.path.join(output_dir, "report")

# Compiler configuration
COMPILERS = {
    'c': {
        'command': 'riscv64-unknown-elf-gcc',
        'extensions': ['.c'],
        'compile_options': ['-Wall', '-Wextra', '-o']
    }
}


def generate_prompt(decompiled_code):

   

    prompt = f"""
    You are an expert software engineer proficient in C programming language and familiar with program verification tools like CPAchecker. I will provide you with C code generated by a decompiler, which may lack necessary variable definitions, header files, and other essential components. Additionally, the code may contain errors that prevent it from compiling successfully. The compilable code will be used for subsequent static analysis to identify defects, so do not alter the semantics that may affect the properties to be verified in the program! Your task is to:

    1. **Add missing header files** required for the code to compile successfully.
    2. **Define any undeclared variables** with appropriate data types.
    3. **Declare and define any missing functions** based on their usage in the code.
    4. **Convert CPAchecker verification properties**  into 'assert' statements, 'assume' statements, or other statements that CPAchecker can process, and remove any custom implementations of assert that may exist in the code.Modify the definition related to assume to void assume(int cond) {{ if(!cond) {{abort();}} }}, and add the missing stdlib.h header file if necessary.
    5. **Ensure the fixed code compiles without errors** using `riscv64-unknown-elf-gcc`.
    6. **Do not add initialization operations for local variables.** In the code to be fixed, keep the local variables that are initialized as they are, and do not initialize the local variables that are uninitialized, leave them uninitialized to satisfy CPAchecker verification requirements.
    7. **Ensure that the semantics that may affect the properties to be verified have not been changed arbitrarily.**
    8. **Let's think step by step.**
    9. **only output the fixed code.**

    **Example 1:**

_Decompiled C code:_
```c
typrdef unsigned long long ulong;
int main() {{
    ulong num;
    while (a = count + 1, iter = counter < 1, counter = a, iter){{num++;}}
    sum = add_numbers(num, 20);
    return 0;
}}
```
Fixed C code:
```c
#include <stdio.h>
typrdef unsigned long long ullong;
ullong add_numbers(ullong a, int b);
int main() {{
    ullong num;
    int counter = 0;
    while (counter < 1){{counter++;num++;}}
    ullong sum = add_numbers(num, 20);
    return 0;
}}

ullong add_numbers(ullong a, int b) {{
    return a + b;
}}
```

Example 2:

Decompiled C code with CPAchecker properties:
'''c
// Global Variables

// func: main

/* WARNING: Variable defined which should be unmapped: y */
/* WARNING: Unknown calling convention */
void assume_abort_if_not(int cond) {{
  if(!cond) {{;}}
}}

int main(void)

{{
  uint local_1c;
  uint local_18;
  uint n;
  uint y;
  uint x;
  
  local_18 = 0;
  assume_abort_if_not(local_18 == 0);
  for (n = local_1c; n != 0; n = n - 1) {{
    local_18 = local_18 + 1;
  }}
  if (local_18 == local_1c) {{
    __assert_func("/home/zyl/biVerify/newData/C_508_1s-30s/0_99backup/process/count_up_down-2_process.c"
                  ,0xf,"main",&_LC0);
  }}
  __blast_assert(0);
  return 0;
}}


// func: __assert_func

/* WARNING: Control flow encountered bad instruction data */

void __assert_func(void)

{{
                    /* WARNING: Bad instruction - Truncating control flow here */
  halt_baddata();
}}
```


Fixed C code:
```c
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>


typedef unsigned int uint;
void assume(int cond) {{
  if(!cond) {{abort();}}
}}
int main(void)
{{
    uint local_1c;    
    uint local_18;
    uint n;
    local_18 = 0;     // keep the local variables that are initialized as they are
    assume(local_18 == 0);

    for (n = local_1c; n != 0; n = n - 1) {{
        local_18 = local_18 + 1;
    }}


    if (local_18 == local_1c) {{
        assert(0 && "Assertion failed: local_18 should not equal local_1c");
    }}
    assert(0);
    return 0;
}}
```

    

    **Decompiled C code:**

    ```c
    {decompiled_code}
    ```
    
    Fixed C code: """ 
    return prompt

def fix_decompiled_code(decompiled_code, compilation_errors=None, iteration=0, messages=[]): 

    error_section = ""
    if iteration == 1:
        prompt = generate_prompt(decompiled_code)
        messages = [
            {"role": "system", "content": "You are an expert software engineer proficient in C programming and familiar with program verification tools like CPAchecker."},
            {"role": "user", "content": prompt},
        ]
        if compilation_errors:
            error_section = f"**Compilation Errors:**\n\n```\n{compilation_errors}\n```"
            messages.append({"role": "user", "content": error_section})
    else:
        if compilation_errors:
            error_section = f"**Compilation Errors:**\n\n```\n{compilation_errors}\n```"
            messages.append({"role": "user", "content": error_section})
    try:
        response = client.chat.completions.create(
            model="deepseek-chat",
            messages=messages,
            max_tokens=4096,
            temperature=0,
            #stop=["```"]
        )
        

        fixed_code = response.choices[0].message.content

        # Use regular expression to extract the C code block and remove `'''c` and `'''`
        match = re.search(r'```c\n(.*?)\n```', fixed_code, re.DOTALL)

        if match:
            # Extract and remove leading and trailing whitespace
            fixed_code = match.group(1).strip()
        else:
            # If no match is found, set to an empty string or handle accordingly
            fixed_code = ""

        # Add the model's response to the conversation history
        messages.append({"role": "assistant", "content": fixed_code})
        
        return fixed_code, messages

    except Exception as e:
        logging.error(f"API request failed: {e}")
        return None
    
def compile_code(file_path, language, output_dir): 
    """ Compile the specified C code file.
    Parameters:
        file_path (str): Path of the code file.
        language (str): The programming language ('c').
        output_dir (str): Directory for the compiled output file.

    Returns:
        tuple: (success: bool, error_message: str)
    """
    compiler_info = COMPILERS.get(language)
    if not compiler_info:
        return False, f"Unsupported language: {language}"

    compiler = compiler_info['command']
    extensions = compiler_info['extensions']

    if not any(file_path.endswith(ext) for ext in extensions):
        return False, f"File extension not supported for language {language}"

    # Build the compile command
    compile_cmd = [compiler] + compiler_info['compile_options']

    # For C code, output the executable file
    project_name = os.path.splitext(os.path.basename(file_path))[0]
    output_executable = os.path.join(output_dir, f"{project_name}_executable")
    compile_cmd += [output_executable, file_path]

    # Run the compile command
    try:
        result = subprocess.run(
            compile_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
        if result.returncode == 0:
            # Compilation successful
            return True, ""
        else:
            # Compilation failed, return the error message
            return False, result.stderr.strip()

    except Exception as e:
        return False, str(e)
    

def categorize_error(error_message): 
    """ Categorize the compilation failure reason based on the error message.
    Parameters:
        error_message (str): The error message returned by the compiler.

    Returns:
        str: The error category.
    """
    error_message = error_message.lower()
    if "undefined reference" in error_message:
        return "Linker Error"
    elif "expected" in error_message or "syntax error" in error_message:
        return "Syntax Error"
    elif "implicit declaration" in error_message or "undeclared" in error_message:
        return "Missing Declaration"
    elif "no such file or directory" in error_message:
        return "Missing Header/File"
    elif "cannot find" in error_message:
        return "Missing Dependency"
    else:
        return "Other Compilation Error"
    


def compile_fixed_code(): 
    """ Iterate over all decompiled C code files, perform iterative fixes and compile, and collect statistical data.
    Returns:
        dict: Compilation statistics.
    """
    statistics = {
        'total': 0,
        'success_count': 0,
        'failure_count': 0,
        'failure_reasons': defaultdict(int),
        'iteration_success': defaultdict(int),  # Track each successful iteration count
        'total_codes': 0,          # New: Total number of codes to be fixed
        'success_codes': 0         # New: Number of codes successfully fixed
    }

    for decompile_dir, fix_dir in FIXED_CODE_PAIRS:
        logging.info(f"Processing directory pair: Decompiled code directory: {decompile_dir} | Fixed output directory: {fix_dir}")
        
        # Ensure the fixed output directory exists
        os.makedirs(fix_dir, exist_ok=True)
        
        # Find all C files
        c_files = glob.glob(os.path.join(decompile_dir, "*.c"))
        all_files = c_files
        
        if not all_files:
            logging.warning(f"No C files found in {decompile_dir}. Skipping.")
            continue
        
        for file_path in all_files:
            language = 'c' if file_path.endswith('.c') else None
            if not language:
                logging.warning(f"Unsupported file type: {file_path}. Skipping.")
                continue
            statistics['total_codes'] += 1  # Increase the total number of codes to be fixed
            project_name = os.path.splitext(os.path.basename(file_path))[0]
            iteration_try_dir = fix_dir
            os.makedirs(iteration_try_dir, exist_ok=True)
            


            iteration = 0
            max_iterations = 5
            compilation_errors = None
            success = False
            messages = []

            while iteration < max_iterations and not success:
                iteration += 1
                statistics['total'] += 1
                logging.info(f"Starting iteration {iteration} fix attempt: {file_path}")
                
                # Read the decompiled code content
                with open(file_path, 'r') as f:
                    decompiled_code = f.read()
                
                # Compile the code once first; if it succeeds, skip the large model fix, else invoke the large model to fix it

                # Call the large model for fixing
                fixed_code, messages = fix_decompiled_code(decompiled_code, compilation_errors, iteration, messages)
                
                if not fixed_code:
                    logging.error(f"Fix failed, unable to get fixed code: {file_path}")
                    break
                
                # Write the fixed code to the iteration output directory
                fixed_file_name = f"{project_name}_iter{iteration}.c"
                fixed_file_path = os.path.join(iteration_try_dir, fixed_file_name)
                with open(fixed_file_path, 'w') as f:
                    f.write(fixed_code)
                logging.info(f"Fixed code saved to: {fixed_file_path}")
                
                # Compile the fixed code
                compile_success, error_message = compile_code(fixed_file_path, language, iteration_try_dir)
                
                if compile_success:
                    statistics['success_count'] += 1
                    statistics['iteration_success'][iteration] += 1
                    statistics['success_codes'] += 1  # Increase the number of successfully fixed codes
                    logging.info(f"Compilation successful: {fixed_file_path} -> Executable")
                    success = True
                else:
                    statistics['failure_count'] += 1
                    category = categorize_error(error_message)
                    statistics['failure_reasons'][category] += 1
                    logging.error(f"Compilation failed: {fixed_file_path} | Reason: {category}")
                    logging.error(f"Error details: {error_message}")
                    compilation_errors = error_message  # Provide the error message for the next round of fixing by the model
            
            if not success:
                logging.error(f"Code fix did not pass compilation after {max_iterations} iterations: {file_path}")

    return statistics


def main(): 
    # Compile the fixed code and collect statistical data
    stats = compile_fixed_code()

if __name__ == "__main__": main()
